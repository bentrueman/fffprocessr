load_icp(path = path)
document()
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
document()
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path) -> test
test
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path) -> test
?return
document()
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path) -> test
test
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
document()
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
document()
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
document()
document()
check()
library(testthat)
path <- system.file("extdata", package = "fffprocessr")
test_that("combine_fff() yields same number of rows as load_...() fns", {
icp_data <- load_icp(path)
uv_data <- load_uv(path, UV254_1, UV254_2, LS90)
expect_equal(
nrow(combine_fff(icp_data, uv_data)),
sum(
nrow(dplyr::filter(icp_data, sample != "blank")),
nrow(dplyr::filter(uv_data, sample != "blank"))
)
)
})
test_that("combine_fff() yields expected column means", {
expect_equal(
dplyr::summarize_if(
combine_fff(load_icp(path), load_uv(path, UV254_1, UV254_2, LS90)) %>% filter(!param %in% c("45Sc", "115In", "159Tb")),
is.numeric, ~ round(mean(.x), 1)
),
tibble::tibble(time = 19, conc = 1.1, three_sigma = .5)
)
})
document()
source("~/Documents/GitHub/fffprocessr/tests/testthat.R", echo=TRUE)
check()
?load_icp
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
document()
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
check()
document()
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
2 %in% 1:10
2 %in% 1:29
2:3 %in% 1:29
TRUE & (2:3 %in% 1:29)
if(TRUE & (2:3 %in% 1:29)) 23
mean(1:2 %in% 1:20) == 0
mean(1:2 %in% 3:20) == 0
mean(1:2 %in% 1:20) == 0
TRUE & mean(1:2 %in% 1:20) == 0
TRUE & mean(1:2 %in% 3:20) == 0
document()
if(
calibrate & mean(unique(calib$date) %in% unique(data$date)) == 0
) stop(
"No calibration file dates match data file dates"
)
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
check()
library(devtools)
document()
load_icp
?load_icp
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path)
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path) %>% distinct(date)
library("tidyverse")
path <- system.file("extdata", package = "fffprocessr")
load_icp(path = path) %>% distinct(date)
document()
check()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%",
dpi = 600
)
options(dplyr.summarise.inform = FALSE)
# rmarkdown::render("README.Rmd", "md_document")
library("fffprocessr")
library("tidyverse")
theme_set(theme_classic() + theme(strip.background = element_blank()))
system.file("extdata", package = "fffprocessr")
icp_data <- system.file("extdata", package = "fffprocessr") %>%
load_icp(calibrate = TRUE)
icp_data
uv_data <- system.file("extdata", package = "fffprocessr") %>%
load_uv(UV254_1, UV254_2, LS90) # name channels in order from left to right
uv_data
data <- combine_fff(
icp_data,
uv_data,
subtract_blank = TRUE,
focus = 10
) %>%
correct_baseline(left = 10, right = 35)
data %>%
filter(time > 5, time < 37.5) %>%
ggplot(aes(time, conc, col = sample)) +
facet_wrap(vars(param), scales = "free_y", ncol = 2) +
geom_hline(yintercept = 0, col = "grey", linetype = 3) +
geom_line()
data %>%
filter(time > 5, time < 37.5, param != "UV254_1") %>%
mutate(
param = fct_recode(param, "UV254" = "UV254_2"),
param = str_remove(param, "^\\d+") %>%
str_replace("([:alpha:]+)(\\d+)$", "\\1[\\2]")
) %>%
ggplot(aes(time, conc, col = sample)) +
facet_wrap(vars(param), scales = "free_y", ncol = 2, labeller = label_parsed) +
geom_hline(yintercept = 0, col = "grey", linetype = 3) +
geom_line() +
scale_colour_manual(values = c("firebrick", "grey")) +
theme(legend.position = "bottom") +
labs(x = "Retention time (min.)", y = "Detector response", col = NULL)
data %>%
filter(
time > 10, # exclude the focus period
param %in% c("55Mn", "56Fe") # select parameters of interest
) %>%
group_by(sample, param) %>%
summarize(conc_ppb = integrate_peak(time, conc))
mals <- system.file("extdata/mals", package = "fffprocessr") %>%
load_mals() %>%
correct_baseline(4, 65)
mals %>%
ggplot(aes(time, conc)) +
facet_wrap(vars(param), scales = "free_y") +
geom_hline(yintercept = 0, col = "grey", linetype = 3) +
geom_line()
mals %>%
filter(
time > 39,
param != "ls7"
) %>%
calculate_rg(window = .05, method = "watt") %>%
filter(timeslice == 40) %>%
distinct(rg_watt) %>%
mutate(d_geom = 2 * rg_watt / sqrt(3/5))
data %>%
filter(param == "65Cu", time > 10.5, time < 16) %>%
mutate(dh = 2 * 1e9 * calculate_rh(time)) %>%
ggplot(aes(dh, conc, col = sample)) +
geom_line()
data %>%
filter(param == "65Cu", time > 10.5, time < 16) %>%
mutate(dh = 2 * 1e9 * calculate_rh(time) ) %>%
ggplot(aes(dh, conc, col = sample)) +
geom_line() +
scale_colour_manual(values = c("firebrick", "grey")) +
labs(x = "Calculated hydrodynamic diameter (nm)", y = "[Cu] (Âµg/L)", col = NULL)
# load a calibration curve:
mw_data <- system.file("extdata/mw_calibration", package = "fffprocessr") %>%
list.files(full.names = TRUE) %>%
read_csv()
mw_data %>%
with(calibrate_mw(peak_retention_time, mw_kda, type = "quadratic", predict = FALSE))
mw_kda
# load a calibration curve:
mw_data <- system.file("extdata/mw_calibration", package = "fffprocessr") %>%
list.files(full.names = TRUE) %>%
read_csv()
mw_data %>%
with(calibrate_mw(peak_retention_time, mw_kda, type = "quadratic", predict = FALSE))
?calibrate_mw
mw_kda
mw_data %>%
with(calibrate_mw(peak_retention_time, type = "quadratic", predict = FALSE))
mw_data %>%
with(calibrate_mw(peak_retention_time, mw_kda, type = "quadratic", predict = FALSE))
fffprocessr::mw_kda
mw_data
# load a calibration curve:
mw_data <- system.file("extdata/mw_calibration", package = "fffprocessr") %>%
list.files(full.names = TRUE) %>%
read_csv()
mw_data %>%
with(calibrate_mw(peak_retention_time, mw_kda, type = "quadratic", predict = FALSE))
# load a calibration curve:
mw_data <- system.file("extdata/mw_calibration", package = "fffprocessr") %>%
list.files(full.names = TRUE) %>%
read_csv()
mw_data %>%
with(calibrate_mw(peak_retention_time, mw_kda, type = "quadratic", predict = FALSE))
mw_data %>%
with(
calibrate_mw(
peak_retention_time,
mw_kda,
type = "quadratic", # or "linear"
newdata = c(1, 10, 100, 1000), # molecular weights (or time if output = "mw")
output = "time", # or "mw"
predict = TRUE
)
)
?with
rmarkdown::render("README.Rmd", "md_document")
library(devtools)
check()
test_coverage()
use_badge
?use_badge
use_github_action_check_release()
use_coverage()
use_github_action("test-coverage")
rmarkdown::render("README.Rmd", "md_document")
library(devtools)
use_test("deconvolve_fff")
?deconvolve_fff
load_all()
?deconvolve_fff
set.seed(0)
x <- seq(0, 10, length.out = 100)
# two gaussian peaks:
y <- exp(-(x - 3) ^ 2 / 2) + exp(-(x - 7) ^ 2 / 2) + rnorm(100, 0, .1)
deconvolve_fff(x, y, h = c(1, 1), mu = c(3, 7), s = c(1, 1), fn = "normal")
?curve
plot(dnorm)
curve(dnorm)
curve(dnorm)
curve(sin, -2*pi, 2*pi, xname = "t")
?dnorm()
dnorm(seq(-2, 2, by = .1))
dnorm(seq(-2, 2, by = .01))
dnorm(seq(-3, 3, by = .01))
set.seed(0)
x <- seq(0, 10, length.out = 100)
# two gaussian peaks:
y <- exp(-(x - 3) ^ 2 / 2) + exp(-(x - 7) ^ 2 / 2) + rnorm(100, 0, .1)
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(3, 7), s = c(1, 1), fn = "normal")
mod
mod$model
coef(mod$model)
set.seed(0)
x <- seq(0, 10, length.out = 100)
# two gaussian peaks:
y <- exp(-(x - 4) ^ 2 / 2) + 2 * exp(-(x - 10 / 3) ^ 2 / 2) + rnorm(100, 0, .1)
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(3, 7), s = c(1, 1), fn = "normal")
coef(mod$model)
plot(x, y)
# two gaussian peaks:
y <- exp(-(x - 4) ^ 2 / 2) + 2 * exp(-(x - 10 / .5) ^ 2 / 2) + rnorm(100, 0, .1)
plot(x, y)
# two gaussian peaks:
y <- exp(-(x - 4) ^ 2 / 2) + .5 * exp(-(x - 10 / .5) ^ 2 / 2) + rnorm(100, 0, .1)
plot(x, y)
# two gaussian peaks:
y <- exp(-(x - 3) ^ 2 / 2) + exp(-(x - 7) ^ 2 / 2) + rnorm(100, 0, .1)
plot(x, y)
# two gaussian peaks:
y <- exp(-(x - 3) ^ 2 / 2) + 2 * exp(-(x - 7) ^ 2 / 2) + rnorm(100, 0, .1)
plot(x, y)
# two gaussian peaks:
y <- exp(-(x - 3) ^ 2 / 2) + 2 * exp(-((x - 7) / 2) ^ 2 / 2) + rnorm(100, 0, .1)
plot(x, y)
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(3, 7), s = c(1, 1), fn = "normal")
coef(mod$model)
set.seed(0)
x <- seq(0, 10, length.out = 200)
# two gaussian peaks:
y <- exp(-(x - 3) ^ 2 / 2) + 2 * exp(-((x - 7) / 2) ^ 2 / 2) + rnorm(100, 0, .1)
plot(x, y)
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(3, 7), s = c(1, 1), fn = "normal")
coef(mod$model)
component
component <- function(h, mu, s) {
h * exp(-0.5 * ((x - mu) / s) ^ 2)
}
set.seed(0)
x <- seq(0, 10, length.out = 200)
# two gaussian peaks:
h1 <- 1
h2 <- 2
mu1 <- 3
mu2 <- 7
s1 <- 1
s2 <- 2
component <- function(h, mu, s) {
h * exp(-0.5 * ((x - mu) / s) ^ 2)
}
noise <- rnorm(100, 0, .1)
y <- component(h1, mu1, s1) + component(h1, mu1, s1) + noise
plot(x, y)
set.seed(0)
x <- seq(0, 10, length.out = 200)
# two gaussian peaks:
h1 <- 1
h2 <- 2
mu1 <- 3
mu2 <- 7
s1 <- 1
s2 <- 2
component <- function(h, mu, s) {
h * exp(-0.5 * ((x - mu) / s) ^ 2)
}
noise <- rnorm(100, 0, .1)
y <- component(h1, mu1, s1) + component(h2, mu2, s2) + noise
plot(x, y)
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(3, 7), s = c(1, 1), fn = "normal")
mod
coef(mod$model)
coef(mod$model) - c(h1, h2, mu1, mu2, s1, s2)
set.seed(0)
x <- seq(0, 10, length.out = 200)
# two gaussian peaks:
h1 <- 1
h2 <- 2
mu1 <- 3
mu2 <- 7
s1 <- 1
s2 <- 2
component <- function(h, mu, s) {
h * exp(-0.5 * ((x - mu) / s) ^ 2)
}
noise <- rnorm(100, 0, .1)
y <- component(h1, mu1, s1) + component(h2, mu2, s2) + noise
plot(x, y)
test_that("deconvolve_fff() fits the expected model", {
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(3, 7), s = c(1, 1), fn = "normal")
d <- coef(mod$model) - c(h1, h2, mu1, mu2, s1, s2)
expect_lt(max(abs(d)), .05)
})
set.seed(0)
x <- seq(0, 10, length.out = 200)
# two gaussian peaks:
h1 <- 1
h2 <- 2
mu1 <- 3
mu2 <- 7
s1 <- 1
s2 <- 2
component <- function(h, mu, s) {
h * exp(-0.5 * ((x - mu) / s) ^ 2)
}
noise <- rnorm(100, 0, .1)
y <- component(h1, mu1, s1) + component(h2, mu2, s2) + noise
plot(x, y)
test_that("deconvolve_fff() fits the expected model", {
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(4,4), s = c(1, 1), fn = "normal")
d <- coef(mod$model) - c(h1, h2, mu1, mu2, s1, s2)
expect_lt(max(abs(d)), .05)
})
set.seed(0)
x <- seq(0, 10, length.out = 200)
# two gaussian peaks:
h1 <- 1
h2 <- 2
mu1 <- 3
mu2 <- 7
s1 <- 1
s2 <- 2
component <- function(h, mu, s) {
h * exp(-0.5 * ((x - mu) / s) ^ 2)
}
noise <- rnorm(100, 0, .1)
y <- component(h1, mu1, s1) + component(h2, mu2, s2) + noise
plot(x, y)
test_that("deconvolve_fff() fits the expected model", {
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(2, 7), s = c(1, 1), fn = "normal")
d <- coef(mod$model) - c(h1, h2, mu1, mu2, s1, s2)
expect_lt(max(abs(d)), .05)
})
set.seed(0)
x <- seq(0, 10, length.out = 200)
# two gaussian peaks:
h1 <- 1
h2 <- 2
mu1 <- 3
mu2 <- 7
s1 <- 1
s2 <- 2
component <- function(h, mu, s) {
h * exp(-0.5 * ((x - mu) / s) ^ 2)
}
noise <- rnorm(100, 0, .1)
y <- component(h1, mu1, s1) + component(h2, mu2, s2) + noise
plot(x, y)
test_that("deconvolve_fff() fits the expected model", {
mod <- deconvolve_fff(x, y, h = c(1, 1), mu = c(2, 7), s = c(1, 1), fn = "normal")
d <- coef(mod$model) - c(h1, h2, mu1, mu2, s1, s2)
expect_lt(max(abs(d)), .05)
})
use_test("integrate_peak")
?integrate_peak
x <- seq(-2, 2, by = .1)
y <- dnorm(x)
integrate_peak(x, y)
x <- seq(-2, 2, by = .01)
y <- dnorm(x)
integrate_peak(x, y)
x <- seq(-2, 2, by = 1e-3)
y <- dnorm(x)
integrate_peak(x, y)
peak_fun
peak_fun <- function(bound) {
x <- seq(-bound, bound, by = 1e-3)
y <- dnorm(x)
integrate_peak(x, y)
}
peak_fun(2)
peak_fun(1)
peak_fun(3)
test_that("integrate_peak() yields expected sum", {
peak_fun <- function(bound) {
x <- seq(-bound, bound, by = 1e-3)
y <- dnorm(x)
integrate_peak(x, y)
}
expect_equal(peak_fun(1), 68.2, tolerance = .1)
})
(peak_fun(1)
peak_fun(1)
expect_equal(peak_fun(1), .682, tolerance = 1e-3)
expect_equal(peak_fun(1), .682, tolerance = 1e-2)
test_that("integrate_peak() yields expected sum", {
peak_fun <- function(bound) {
x <- seq(-bound, bound, by = 1e-3)
y <- dnorm(x)
integrate_peak(x, y)
}
expect_equal(peak_fun(1), .682, tolerance = 1e-2)
})
expect_equal(peak_fun(2), .954, tolerance = 1e-2)
expect_equal(peak_fun(3), .997, tolerance = 1e-2)
test_that("integrate_peak() yields expected sum", {
peak_fun <- function(bound) {
x <- seq(-bound, bound, by = 1e-3)
y <- dnorm(x)
integrate_peak(x, y)
}
expect_equal(peak_fun(1), .682, tolerance = 1e-2)
expect_equal(peak_fun(2), .954, tolerance = 1e-2)
expect_equal(peak_fun(3), .997, tolerance = 1e-2)
})
use_test("calculate_rh")
?calculate_rh
tr <- seq(11.6, 15.6, by = .1)
calculate_rh(tr)
tr <- seq(11.6, 15.6, by = .1)
calculate_rh(tr)
1.318561e-09 * 1e9
tr <- seq(11.6, 15.6, by = 1)
calculate_rh(tr)
test_that("multiplication works", {
tr <- seq(11.6, 15.6, by = 1)
ref <- c(1.055725e-11, 3.375582e-10, 6.645592e-10, 9.915602e-10, 1.318561e-09)
calculated <- calculate_rh(tr)
expect_equal(calculated, ref)
})
test_that("calculate_rh() yields the expected hydrodynamic radii", {
tr <- seq(11.6, 15.6, by = 1)
ref <- c(1.055725e-11, 3.375582e-10, 6.645592e-10, 9.915602e-10, 1.318561e-09)
calculated <- calculate_rh(tr)
expect_equal(calculated, ref)
})
?calibrate_mw
use_Test("calibrate_mw")
use_test("calibrate_mw")
retention <- c(11.35890, 19.49773, 19.24173, 13.88310, 18.73001, 17.67315)
mw_kda <- c(0.69, 2000.00, 440.00, 1.80, 158.00, 44.00)
# return tick positions for 1, 10, 100, and 1000 kDa,
# based on a quadratic calibration curve:
calibrate_mw(retention, mw_kda, newdata = c(1, 10, 100, 1000), predict = TRUE)
test_that("multiplication works", {
retention <- c(11.35890, 19.49773, 19.24173, 13.88310, 18.73001, 17.67315)
mw_kda <- c(0.69, 2000.00, 440.00, 1.80, 158.00, 44.00)
ref <- c(13.25712, 16.41176, 18.15480, 19.51300)
calculated <- calibrate_mw(retention, mw_kda, newdata = c(1, 10, 100, 1000), predict = TRUE)
expect_equal(ref, calculated)
})
test_that("multiplication works", {
retention <- c(11.35890, 19.49773, 19.24173, 13.88310, 18.73001, 17.67315)
mw_kda <- c(0.69, 2000.00, 440.00, 1.80, 158.00, 44.00)
ref <- c(13.257117, 16.411758, 18.154797, 19.513002)
calculated <- calibrate_mw(retention, mw_kda, newdata = c(1, 10, 100, 1000), predict = TRUE)
expect_equal(ref, calculated)
})
test_that("calibrate_mw() yields the expected retention times", {
retention <- c(11.35890, 19.49773, 19.24173, 13.88310, 18.73001, 17.67315)
mw_kda <- c(0.69, 2000.00, 440.00, 1.80, 158.00, 44.00)
ref <- c(13.257117, 16.411758, 18.154797, 19.513002)
calculated <- calibrate_mw(retention, mw_kda, newdata = c(1, 10, 100, 1000), predict = TRUE)
expect_equal(ref, calculated)
})
check()
test_coverage()
